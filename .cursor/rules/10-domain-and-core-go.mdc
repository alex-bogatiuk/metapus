---
description: "Metapus: правила для `internal/core` и `internal/domain` (DDD/инварианты, сервисы/use-cases, интерфейсы репозиториев, тестируемость)."
globs:
  - "internal/core/**/*.go"
  - "internal/domain/**/*.go"
alwaysApply: false
---

## DDD и границы

- **Bounded context = подкаталог в `internal/domain/*`** (например, `catalogs/*`, `documents/*`, `registers/*`, `auth/*`).
- Доменные типы должны быть **самодостаточны**: инварианты в `Validate(ctx)`, бизнес‑методы на структурах (где уместно).
- **Domain events** (если добавляешь) — в домене как типы/контракты; публикация через outbox/адаптеры — в инфраструктуре.

## Сервисы и use cases

- Сервис в домене:
  - оркестрирует use case,
  - вызывает `Validate`,
  - запускает транзакцию через `tx.Manager`,
  - зовёт репозитории через интерфейсы,
  - дергает хуки (расширяемость), но не знает о конкретных провайдерах/транспорте.
- **TxManager/tenant берём из `context`**, если это принятая модель (см. `domain.CatalogService.getTxManager`).

## Репозитории (контракты)

- Интерфейсы репозиториев объявляй в домене рядом с моделью (`repo.go`).
- Репозиторий не должен протаскивать HTTP/DTO‑типы; на границах только доменные типы и `context`.
- Для конкурентности:
  - в доменных контрактах допустимы методы вроде `Lock/GetForUpdate` (явные блокировки),
  - optimistic locking — через `Version` и проверку affected rows (реализация в infra).

## Инварианты и вычисления

- `Validate(ctx)`:
  - проверяет **только** внутреннюю согласованность сущности,
  - **не ходит** в БД/сеть.
- Вычисления (`Calculate`, `GenerateMovements` и т.п.) должны быть **детерминированы** и легко тестироваться.

## Immutable ledger и перепроведение (если трогаешь posting/registers)

- Движения регистров **не обновляем** (без `UPDATE` в movements): новая версия движений на перепроведение.
- Delta‑обновление остатков: считаем дельту между old/new движениями.
- Для предотвращения deadlock:
  - применяй **resource ordering** (сортировка по ключам измерений до блокировок/обновлений).

## Go стиль и ошибки

- Пиши idiomatic Go:
  - ошибки: `fmt.Errorf("...: %w", err)`; не теряй контекст.
  - не игнорируй `ctx`; никаких `context.Background()` внутри бизнес‑логики.
  - избегай преждевременных micro‑оптимизаций; сначала простота, затем профилирование.

## Тестируемость (обязательное)

- Use cases/сервисы должны покрываться unit‑тестами через фейки репозиториев и зависимостей.
- Если логика зависит от времени/ID:
  - вводи интерфейсы (Clock/IDGen) на границе use case,
  - или передавай значения параметрами (лучше для детерминизма).

