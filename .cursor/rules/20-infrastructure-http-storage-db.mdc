---
description: "Metapus: правила для `internal/infrastructure`, `cmd`, `db` (адаптеры, DI/composition root, Postgres/pgx, миграции, observability, graceful shutdown)."
globs:
  - "internal/infrastructure/**/*.go"
  - "cmd/**/*.go"
  - "db/**/*.sql"
alwaysApply: false
---

## Composition root (`cmd/*`)

- В `cmd/*/main.go`:
  - собирай зависимости (DI руками),
  - настраивай логирование/конфиг,
  - поднимай HTTP/router/worker,
  - делай **graceful shutdown** (context cancellation, закрытие пулов).

## HTTP слой (`internal/infrastructure/http`)

- Handler = тонкий адаптер:
  - парсит/валидирует вход (структурно),
  - маппит DTO ↔ domain,
  - вызывает доменный сервис,
  - преобразует ошибки в HTTP‑ответы.
- Auth/tenant/trace/logging — через middleware, не вручную в каждом handler.

## Postgres слой (`internal/infrastructure/storage/postgres`)

- Используй `pgx/pgxpool` и явные транзакции через `TxManager`.
- В Database‑per‑Tenant режиме:
  - `TxManager` и подключение берутся из `context` (middleware/worker),
  - **никаких tenant discriminator колонок и фильтрации по tenant в SQL**.
- SQL:
  - предпочитай простые запросы,
  - следи за индексами под фильтры/сортировки,
  - избегай N+1 на горячих путях.

## Миграции (`db/migrations`)

- Любая новая сущность (catalog/document/register) должна сопровождаться миграцией.
- Схему именования соблюдай как контракт (префиксы `cat_`, `doc_`, `reg_`, `sys_`, `const_` — см. `Manifest.md`).
- Если добавляешь триггеры/CDC/audit — делай это типовым паттерном и документируй причину.

## Observability

- Логи: структурированные поля (tenant, request_id/trace_id, user_id где уместно).
- Метрики/healthchecks: добавляй только если есть потребитель/сценарий; иначе фиксируй TODO в docs/roadmap.

## Производительность: правила здравого смысла

- Оптимизируй только после измерений (pprof/benchmarks).
- Для bulk операций используй батчи/CopyFrom (где оправдано).
- Не усложняй ради “нулевых аллокаций” без доказанной выгоды.

