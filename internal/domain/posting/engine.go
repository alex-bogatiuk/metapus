// Package posting provides the document posting engine.
// Posting is the process of recording document movements to accumulation registers.
package posting

import (
	"context"
	"fmt"
	"sort"

	"metapus/internal/core/apperror"
	"metapus/internal/core/entity"
	"metapus/internal/core/id"
	"metapus/internal/core/tenant"
	"metapus/internal/domain/registers/stock"
	"metapus/pkg/logger"
)

// Postable is implemented by documents that can generate register movements.
type Postable interface {
	// GetID returns the document ID
	GetID() id.ID

	// GetDocumentType returns the document type name (e.g., "GoodsReceipt")
	GetDocumentType() string

	// GetPostedVersion returns the current posting version
	GetPostedVersion() int

	// IsPosted returns true if document is currently posted
	IsPosted() bool

	// CanPost validates if document can be posted
	CanPost(ctx context.Context) error

	// GenerateMovements creates register movements for this document
	// Called within a transaction during posting
	GenerateMovements(ctx context.Context) (*MovementSet, error)

	// MarkPosted updates the document's posted state
	MarkPosted()

	// MarkUnposted clears the posted state
	MarkUnposted()
}

// MovementSet contains all register movements generated by a document.
// NOTE: CostMovements and SettlementMovements removed (YAGNI).
// Add them when actual implementation is needed.
type MovementSet struct {
	StockMovements []entity.StockMovement
}

// NewMovementSet creates an empty movement set.
func NewMovementSet() *MovementSet {
	return &MovementSet{}
}

// AddStock adds a stock movement.
func (m *MovementSet) AddStock(movement entity.StockMovement) {
	m.StockMovements = append(m.StockMovements, movement)
}

// IsEmpty returns true if no movements were generated.
func (m *MovementSet) IsEmpty() bool {
	return len(m.StockMovements) == 0
}

// TotalCount returns total number of movements.
func (m *MovementSet) TotalCount() int {
	return len(m.StockMovements)
}

// Engine orchestrates document posting operations.
// It coordinates validation, movement generation, and register updates.
// In Database-per-Tenant architecture, TxManager is obtained from context.
type Engine struct {
	stockService *stock.Service
	// Future: costService, settlementService

	// Hooks for extensibility
	beforePost []PostHook
	afterPost  []PostHook
}

// PostHook is called during posting lifecycle.
type PostHook func(ctx context.Context, doc Postable) error

// NewEngine creates a new posting engine.
// In Database-per-Tenant, TxManager is obtained from context.
func NewEngine(
	stockService *stock.Service,
) *Engine {
	return &Engine{
		stockService: stockService,
	}
}

// OnBeforePost registers a hook to run before posting.
func (e *Engine) OnBeforePost(hook PostHook) {
	e.beforePost = append(e.beforePost, hook)
}

// OnAfterPost registers a hook to run after posting.
func (e *Engine) OnAfterPost(hook PostHook) {
	e.afterPost = append(e.afterPost, hook)
}

// Post records document movements to registers.
// This is the main posting operation - it:
// 1. Validates the document can be posted
// 2. Generates movements from document data
// 3. Checks stock availability (for expense movements)
// 4. Records movements to registers
// 5. Updates document posted state
//
// If the document is already posted, it will be re-posted (like 1C behavior).
func (e *Engine) Post(ctx context.Context, doc Postable, updateDoc func(context.Context) error) error {
	// If already posted, do repost (перепроведение like in 1C)
	if doc.IsPosted() {
		return e.Repost(ctx, doc, updateDoc)
	}

	// 2. Validate document can be posted
	if err := doc.CanPost(ctx); err != nil {
		return fmt.Errorf("cannot post: %w", err)
	}

	// 3. Run before-post hooks
	for _, hook := range e.beforePost {
		if err := hook(ctx, doc); err != nil {
			return fmt.Errorf("before-post hook: %w", err)
		}
	}

	// 4. Execute posting in transaction
	txm, err := tenant.GetTxManager(ctx)
	if err != nil {
		return apperror.NewInternal(err).WithDetail("missing", "tx_manager")
	}
	err = txm.RunInTransaction(ctx, func(ctx context.Context) error {
		// Generate movements
		movements, err := doc.GenerateMovements(ctx)
		if err != nil {
			return fmt.Errorf("generate movements: %w", err)
		}

		if movements.IsEmpty() {
			logger.Warn(ctx, "document generated no movements",
				"document_id", doc.GetID(),
				"document_type", doc.GetDocumentType())
		}

		// Check stock availability for expense movements
		if err := e.validateStockAvailability(ctx, movements.StockMovements); err != nil {
			return err
		}

		// Record movements to registers
		if err := e.recordMovements(ctx, movements); err != nil {
			return fmt.Errorf("record movements: %w", err)
		}

		// Update document posted state
		doc.MarkPosted()
		if err := updateDoc(ctx); err != nil {
			return fmt.Errorf("update document: %w", err)
		}

		return nil
	})

	if err != nil {
		return err
	}

	// 5. Run after-post hooks (outside transaction)
	for _, hook := range e.afterPost {
		if hookErr := hook(ctx, doc); hookErr != nil {
			logger.Error(ctx, "after-post hook failed",
				"document_id", doc.GetID(),
				"error", hookErr)
		}
	}

	logger.Info(ctx, "document posted",
		"document_id", doc.GetID(),
		"document_type", doc.GetDocumentType(),
		"version", doc.GetPostedVersion())

	return nil
}

// Unpost reverses document movements from registers.
func (e *Engine) Unpost(ctx context.Context, doc Postable, updateDoc func(context.Context) error) error {
	if !doc.IsPosted() {
		return apperror.NewBusinessRule(
			"DOCUMENT_NOT_POSTED",
			"Document is not posted",
		).WithDetail("document_id", doc.GetID().String())
	}

	txm, err := tenant.GetTxManager(ctx)
	if err != nil {
		return apperror.NewInternal(err).WithDetail("missing", "tx_manager")
	}
	err = txm.RunInTransaction(ctx, func(ctx context.Context) error {
		// Delete movements for this document version
		// This uses recorder_id + recorder_version for efficient cleanup
		if err := e.stockService.ReverseMovements(ctx, doc.GetID(), doc.GetPostedVersion()+1); err != nil {
			return fmt.Errorf("reverse stock movements: %w", err)
		}

		// Update document state
		doc.MarkUnposted()
		if err := updateDoc(ctx); err != nil {
			return fmt.Errorf("update document: %w", err)
		}

		return nil
	})

	if err != nil {
		return err
	}

	logger.Info(ctx, "document unposted",
		"document_id", doc.GetID(),
		"document_type", doc.GetDocumentType())

	return nil
}

// Repost re-posts a document (unpost + post in single transaction).
// Used when document data changes while posted.
func (e *Engine) Repost(ctx context.Context, doc Postable, updateDoc func(context.Context) error) error {
	if !doc.IsPosted() {
		// If not posted, just post
		return e.Post(ctx, doc, updateDoc)
	}

	// Validate first
	if err := doc.CanPost(ctx); err != nil {
		return fmt.Errorf("cannot repost: %w", err)
	}

	txm, err := tenant.GetTxManager(ctx)
	if err != nil {
		return apperror.NewInternal(err).WithDetail("missing", "tx_manager")
	}
	err = txm.RunInTransaction(ctx, func(ctx context.Context) error {
		// 1. Delete old movements (but don't change posted state yet)
		oldVersion := doc.GetPostedVersion()
		if err := e.stockService.ReverseMovements(ctx, doc.GetID(), oldVersion+1); err != nil {
			return fmt.Errorf("reverse old movements: %w", err)
		}

		// 2. Generate new movements
		movements, err := doc.GenerateMovements(ctx)
		if err != nil {
			return fmt.Errorf("generate movements: %w", err)
		}

		// 3. Validate stock availability
		if err := e.validateStockAvailability(ctx, movements.StockMovements); err != nil {
			return err
		}

		// 4. Record new movements
		if err := e.recordMovements(ctx, movements); err != nil {
			return fmt.Errorf("record movements: %w", err)
		}

		// 5. Update document (increments posted version)
		doc.MarkPosted()
		if err := updateDoc(ctx); err != nil {
			return fmt.Errorf("update document: %w", err)
		}

		return nil
	})

	if err != nil {
		return err
	}

	logger.Info(ctx, "document reposted",
		"document_id", doc.GetID(),
		"document_type", doc.GetDocumentType(),
		"version", doc.GetPostedVersion())

	return nil
}

// validateStockAvailability checks if there's enough stock for expense movements.
func (e *Engine) validateStockAvailability(ctx context.Context, movements []entity.StockMovement) error {
	// Collect expense movements by warehouse+product
	reserves := make(map[string]stock.StockReservation)

	for _, m := range movements {
		if m.RecordType != entity.RecordTypeExpense {
			continue
		}

		key := m.WarehouseID.String() + ":" + m.ProductID.String()
		if existing, ok := reserves[key]; ok {
			existing.RequiredQty += m.Quantity
			reserves[key] = existing
		} else {
			reserves[key] = stock.StockReservation{
				WarehouseID: m.WarehouseID,
				ProductID:   m.ProductID,
				RequiredQty: m.Quantity,
			}
		}
	}

	if len(reserves) == 0 {
		return nil
	}

	// Convert to slice and check availability
	items := make([]stock.StockReservation, 0, len(reserves))
	for _, r := range reserves {
		items = append(items, r)
	}

	// IMPORTANT: Lock balances in deterministic order to prevent deadlocks.
	// (Classic AB-BA pattern when multiple transactions lock the same rows.)
	sort.Slice(items, func(i, j int) bool {
		ai := items[i].WarehouseID.String() + ":" + items[i].ProductID.String()
		aj := items[j].WarehouseID.String() + ":" + items[j].ProductID.String()
		return ai < aj
	})

	return e.stockService.CheckAndReserveStock(ctx, items)
}

// recordMovements saves movements to all registers.
func (e *Engine) recordMovements(ctx context.Context, movements *MovementSet) error {
	// Record stock movements
	if len(movements.StockMovements) > 0 {
		if err := e.stockService.RecordMovements(ctx, movements.StockMovements); err != nil {
			return fmt.Errorf("stock movements: %w", err)
		}
	}

	// Future: record cost movements
	// Future: record settlement movements

	return nil
}
