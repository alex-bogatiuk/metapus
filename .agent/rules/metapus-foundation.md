---
trigger: always_on
---

---
description: "Metapus: базовые принципы (metadata-driven Go, Clean Architecture, multi-tenancy DB-per-tenant, immutable ledger)."
---

## Источник истины

- **Всегда сверяйся с `@Manifest.md`**: это архитектурная «конституция» проекта.
- Для быстрых практических шагов используй `@docs/QUICK_REFERENCE.md`.

## Приоритеты при проектировании (по убыванию)

- **Расширяемость**: поведение должно задаваться конфигурацией/метаданными и расширяемыми точками (хуки, интерфейсы), а не хардкодом.
- **Читаемость**: Clean Architecture + уместный DDD.
- **Производительность**: простые и эффективные решения.

## Архитектура (Clean Architecture + dependency rule)

- **`internal/core`**: фундаментальные типы и политики (entity/base types, ошибки, tenant context, tx).
- **`internal/domain`**: бизнес‑логика и use cases (сервисы, интерфейсы репозиториев, инварианты).
- **`internal/infrastructure`**: драйверы/адаптеры (HTTP, Postgres, cache, worker).
- **`cmd/*`**: composition root (склейка зависимостей, конфиг, запуск, graceful shutdown).

Правило зависимости: **внутренние слои не импортируют внешние**. Domain ничего не должен знать о HTTP/Postgres и т.п.

## Metadata-driven подход в Metapus

- Здесь **«code is metadata»**: метаданные системы выражаются **компилируемыми Go‑структурами и контрактами**, а не «универсальными» JSON‑описаниями схем в БД.
- Теги `db/json` — часть контракта: они связывают слой домена/DTO/хранилища.
- Если нужно расширение под конкретный проект/клиента: предпочитай **хуки/плагины/интерфейсы** и регистрационные механизмы, а не ветвления по флагам внутри core-domain.

## Multi-tenancy: Database-per-Tenant (важно)

- Основная модель изоляции: **отдельная БД на тенанта**, поэтому:
  - не добавляй “tenant discriminator” колонки в бизнес‑таблицы и не добавляй фильтрацию по tenant в SQL.
  - tenant/tx/pool получают через `context.Context` (см. `tenant.MustGetTxManager(ctx)` и middleware).

## Ошибки, контракты и наблюдаемость

- Возвращай **типизированные/структурированные ошибки** (см. `internal/core/apperror`), не «строки».
- Всегда прокидывай `context.Context` через границы слоёв (handlers → services → repos).
- Логи должны быть **структурированными** (ключ-значение) и пригодными для трассировки.

## Как отвечать и предлагать изменения

- Всегда объясняй **почему** выбран подход.
- Если меняешь архитектуру/контракты — показывай **предлагаемую структуру пакетов** и как это вписывается в слои.